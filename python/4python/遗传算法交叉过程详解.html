<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>遗传算法交叉(Crossover)过程演示</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', 'SimHei', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .canvas-container {
            border: 1px solid #e5e7eb;
            background-color: #ffffff;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .control-button {
            padding: 0.6rem 1.2rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .control-button:disabled {
            background-color: #d1d5db;
            cursor: not-allowed;
        }
        .control-button:active {
            transform: translateY(1px);
            box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
        }
        .explanation-box {
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            min-height: 100px;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 max-w-7xl">
        <header class="text-center mb-6">
            <h1 class="text-3xl font-extrabold text-gray-900">遗传算法“交叉”过程详解</h1>
            <p class="text-md text-gray-600 mt-2">观察“子代”如何学习“父母”的优秀基因</p>
        </header>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
            <!-- Parent A -->
            <div class="canvas-container rounded-xl p-4">
                <h2 class="text-center font-bold text-xl mb-2">父代 A</h2>
                <canvas id="parentACanvas"></canvas>
            </div>
            <!-- Parent B -->
            <div class="canvas-container rounded-xl p-4">
                <h2 class="text-center font-bold text-xl mb-2">父代 B</h2>
                <canvas id="parentBCanvas"></canvas>
            </div>
            <!-- Child -->
            <div class="canvas-container rounded-xl p-4">
                <h2 class="text-center font-bold text-xl mb-2">新生的子代</h2>
                <canvas id="childCanvas"></canvas>
            </div>
        </div>

        <div class="flex flex-col md:flex-row gap-6 items-start">
            <!-- Controls -->
            <div class="w-full md:w-64 bg-white p-6 rounded-xl shadow-lg border text-center">
                <h2 class="text-xl font-bold mb-4">操作面板</h2>
                <div class="space-y-4">
                    <button id="generateParentsBtn" class="control-button bg-blue-500 text-white w-full hover:bg-blue-600">1. 随机生成父代</button>
                    <button id="crossoverBtn" class="control-button bg-green-500 text-white w-full hover:bg-green-600" disabled>2. 执行交叉</button>
                </div>
            </div>

            <!-- Explanation -->
            <div class="flex-grow bg-white p-6 rounded-xl shadow-lg border">
                <h2 class="text-xl font-bold mb-2">过程讲解</h2>
                <div id="explanationText" class="explanation-box rounded-lg p-4 text-gray-700">
                    请点击“随机生成父代”按钮开始。
                </div>
            </div>
        </div>
    </div>

<script>
    const parentACanvas = document.getElementById('parentACanvas');
    const parentBCanvas = document.getElementById('parentBCanvas');
    const childCanvas = document.getElementById('childCanvas');

    const canvases = {
        parentA: { ctx: parentACanvas.getContext('2d'), el: parentACanvas },
        parentB: { ctx: parentBCanvas.getContext('2d'), el: parentBCanvas },
        child: { ctx: childCanvas.getContext('2d'), el: childCanvas },
    };

    const generateParentsBtn = document.getElementById('generateParentsBtn');
    const crossoverBtn = document.getElementById('crossoverBtn');
    const explanationText = document.getElementById('explanationText');

    const CITY_COUNT = 8;
    let cities = [];
    let parentAOrder, parentBOrder, childOrder;
    let isAnimating = false;

    // --- UTILITY FUNCTIONS ---
    const sleep = (ms) => new Promise(res => setTimeout(res, ms));
    const shuffle = (array) => {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    };

    // --- DRAWING FUNCTIONS ---
    function resizeCanvases() {
        for (const key in canvases) {
            const canvasEl = canvases[key].el;
            const parent = canvasEl.parentElement;
            canvasEl.width = parent.clientWidth - 32; // 32 is for padding
            canvasEl.height = canvasEl.width; // Make it square
        }
    }

    function drawCities(ctx, specificCities = null) {
        ctx.fillStyle = '#cbd5e1'; // gray-300
        const cityList = specificCities || cities;
        cityList.forEach(city => {
            ctx.beginPath();
            ctx.arc(city.x, city.y, 6, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    function drawPath(ctx, order, color, lineWidth, segment = null, segmentColor = '#ef4444', segmentWidth = 5) {
        if (!order || order.length === 0) return;
        
        const drawSegment = (startIdx, endIdx, c, lw) => {
            ctx.strokeStyle = c;
            ctx.lineWidth = lw;
            ctx.beginPath();
            ctx.moveTo(cities[order[startIdx]].x, cities[order[startIdx]].y);
            for (let i = startIdx + 1; i < endIdx; i++) {
                ctx.lineTo(cities[order[i]].x, cities[order[i]].y);
            }
            ctx.stroke();
        };

        // Draw main path
        ctx.strokeStyle = color;
        ctx.lineWidth = lineWidth;
        ctx.beginPath();
        ctx.moveTo(cities[order[0]].x, cities[order[0]].y);
        for (let i = 1; i < order.length; i++) {
            ctx.lineTo(cities[order[i]].x, cities[order[i]].y);
        }
        ctx.lineTo(cities[order[0]].x, cities[order[0]].y); // Close loop
        ctx.stroke();

        // Draw highlighted segment on top
        if (segment) {
            ctx.strokeStyle = segmentColor;
            ctx.lineWidth = segmentWidth;
            ctx.beginPath();
            ctx.moveTo(cities[segment[0]].x, cities[segment[0]].y);
            for(let i = 1; i < segment.length; i++) {
                ctx.lineTo(cities[segment[i]].x, cities[segment[i]].y);
            }
            ctx.stroke();
        }
    }
    
    function clearCanvas(key) {
        const { ctx, el } = canvases[key];
        ctx.clearRect(0, 0, el.width, el.height);
    }
    
    function redrawAll(highlightSegment = null) {
        for (const key in canvases) {
            clearCanvas(key);
            drawCities(canvases[key].ctx);
        }
        
        drawPath(canvases.parentA.ctx, parentAOrder, '#60a5fa', 3, highlightSegment);
        drawPath(canvases.parentB.ctx, parentBOrder, '#60a5fa', 3);
        drawPath(canvases.child.ctx, childOrder, '#60a5fa', 3, highlightSegment);
    }


    // --- CORE LOGIC ---
    function init() {
        resizeCanvases();
        const padding = 30;
        cities = [];
        const baseWidth = canvases.parentA.el.width;
        const baseHeight = canvases.parentA.el.height;

        for (let i = 0; i < CITY_COUNT; i++) {
            cities.push({
                x: Math.random() * (baseWidth - padding * 2) + padding,
                y: Math.random() * (baseHeight - padding * 2) + padding,
            });
        }
        explanationText.textContent = '请点击“随机生成父代”按钮开始。';
        for (const key in canvases) {
           clearCanvas(key);
           drawCities(canvases[key].ctx);
        }
    }

    async function handleGenerateParents() {
        if (isAnimating) return;
        parentAOrder = shuffle(Array.from(Array(CITY_COUNT).keys()));
        parentBOrder = shuffle(Array.from(Array(CITY_COUNT).keys()));
        childOrder = [];

        redrawAll();

        explanationText.innerHTML = `已生成两条父代路线。它们都是不错的解决方案。<br>现在我们将从它们身上学习，创造出新的“子代”。`;
        crossoverBtn.disabled = false;
    }
    
    async function handleCrossover() {
        if (isAnimating) return;
        isAnimating = true;
        generateParentsBtn.disabled = true;
        crossoverBtn.disabled = true;

        // Step 1: Select a random subsequence from Parent A
        let start = Math.floor(Math.random() * parentAOrder.length);
        let end = Math.floor(Math.random() * (parentAOrder.length - start)) + start + 1;
        let geneSegment = parentAOrder.slice(start, end);

        explanationText.innerHTML = `<strong>第1步:</strong> 我们从“父代A”中随机选择一段基因（一段城市序列）。`;
        redrawAll(geneSegment);
        await sleep(2000);

        // Step 2: Copy this subsequence to the Child
        childOrder = [...geneSegment];
        explanationText.innerHTML = `<strong>第2步:</strong> 将这段基因直接复制给“子代”。子代继承了父代A的这个优秀片段。`;
        redrawAll(geneSegment);
        await sleep(2000);

        // Step 3: Fill the remaining spots from Parent B
        explanationText.innerHTML = `<strong>第3步:</strong> 现在，我们按顺序从“父代B”中选取剩余的城市，来填补“子代”的空缺。`;
        await sleep(1500);

        let parentBIndex = 0;
        while (childOrder.length < CITY_COUNT) {
            let cityToAdd = parentBOrder[parentBIndex];
            if (!childOrder.includes(cityToAdd)) {
                childOrder.push(cityToAdd);
                redrawAll(geneSegment);
                 await sleep(800);
            }
            parentBIndex++;
        }
        
        explanationText.innerHTML = `<strong>完成！</strong> “子代”诞生了。<br>它既保留了父代A的一部分特征，也学习了父代B的城市顺序，是一个全新的、可能更优的解决方案。`;

        isAnimating = false;
        generateParentsBtn.disabled = false;
        crossoverBtn.disabled = false;
    }

    // --- Event Listeners ---
    generateParentsBtn.addEventListener('click', handleGenerateParents);
    crossoverBtn.addEventListener('click', handleCrossover);
    window.addEventListener('resize', init);
    
    init();

</script>
</body>
</html>
